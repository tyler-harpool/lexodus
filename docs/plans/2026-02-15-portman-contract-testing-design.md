# Portman Contract Testing Design

## Goal

Full contract testing of all 396 API endpoints using Portman to auto-generate schema validation, status code assertions, and response structure tests from the OpenAPI spec. All endpoints receive valid, seeded data and return success responses.

## Approach

Use [Portman](https://github.com/apideck-libraries/portman) to convert `openapi-description.json` into a Postman collection with auto-generated contract tests. A single `portman-config.json` drives ordering, variable capture, request body overwrites, and auth injection. Newman executes the generated collection.

## Architecture

```
portman-config.json          <- Single config file
  ├── orderOfOperations      <- Dependency-ordered request sequence
  ├── assignVariables        <- Capture IDs from create responses
  ├── overwrites             <- Inject realistic federal court request bodies
  ├── tests.contractTests    <- Schema validation, status codes, response times
  └── operationPreRequestScripts  <- Auth token injection

openapi-description.json     <- Source of truth (utoipa-generated)
postman/newman-env.json      <- Base URL, test credentials (already exists)
```

## Test Types (auto-generated by Portman)

- **Schema validation**: Response body validated against OpenAPI `components/schemas`
- **Status code assertions**: 2xx for happy path, 4xx for error paths
- **Content-type checks**: `application/json` header verification
- **Response time**: Configurable thresholds
- **JSON body structure**: Required fields present

## Data Seeding Strategy

Ordered collection folders via `orderOfOperations`:

1. **Auth**: Register user -> capture `access_token`
2. **Cases**: Create case -> capture `case_id`
3. **Attorneys**: Create attorney -> capture `attorney_id`
4. **Judges**: Create judge -> capture `judge_id`
5. **Defendants**: Create defendant -> capture `defendant_id`
6. **Parties**: Create party -> capture `party_id`
7. **Docket**: Create entries -> capture `docket_entry_id`
8. **Filings**: Create filing -> capture `filing_id`
9. **All other domains**: Use captured IDs

Each create response's ID is captured via `assignVariables` with `responseBodyProp` and reused in subsequent requests via `{{variable}}` syntax.

## Auth Flow

Collection-level pre-request script:
1. Register test user via `POST /api/v1/auth/register` (with `display_name` field)
2. Fallback to login if user exists
3. Store `access_token` as collection variable
4. All subsequent requests use `Authorization: Bearer {{access_token}}`

## Negative Tests

Portman variation tests for:
- Missing auth token -> 401
- Invalid request body -> 422
- Nonexistent UUID -> 404
- Wrong HTTP method -> 405

## Request Bodies

Realistic federal court data injected via `overwrites`:
- Cases: title, crime_type (Felony), district_code (district9)
- Attorneys: bar_number, name, address, phone
- Docket entries: case_id, entry_type (Motion), description
- All entities use district9/district12 per project conventions

## File Layout

```
postman/
  portman-config.json       <- Portman configuration
  newman-env.json           <- Environment variables (exists)
  lexodus-contract.json     <- Generated collection (Portman output)
  results.json              <- Newman results (gitignored)
```

## Run Commands

```bash
npx @apideck/portman \
  --local openapi-description.json \
  --portmanConfigFile postman/portman-config.json \
  --envFile postman/newman-env.json \
  --output postman/lexodus-contract.json \
  --includeTests

newman run postman/lexodus-contract.json \
  -e postman/newman-env.json \
  --reporters cli,json \
  --reporter-json-export postman/results.json
```

## Complements Existing Rust Tests

- Newman/Portman: HTTP contract layer (routes, status codes, response schemas)
- Rust integration tests: Business logic, isolation, edge cases, DB constraints
- No duplication — different testing layers

## Dependencies

- `@apideck/portman` (npm, installed locally)
- `newman` (already installed globally)
- Running server on localhost:8080 with database
